#pragma config(Motor,  port1,           LBDrive,       tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LFDrive,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           RBLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LBLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RTLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LTLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           RClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RFDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RBDrive,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

	int FULL = 127; 		// Please only use this for the lifts.
  int HALF = 64;  		// Only necessary for testing speeds.
  int TILE = 500;     //
  int HALFTILE = 250; // Theoretically accurate.
  int CONTROL = 15;		// Use this to maintain the lift.
  int LEFT = (Ch3); 	// These two settings are
  int RIGHT = (Ch2);	// for the controllers.
  int SPEED = 100;  	// The Theoretically proper speed for the four wheels. IDK IDK IDK IDK maybe

void pre_auton()// This is necessary
{
}

void ClawClose()
{
	startMotor(LClaw,127);
	startMotor(RClaw,127);
	wait(1);
	stopMotor(LClaw);
	stopMotor(RClaw);
}
void ClawOpen()
{
	startMotor(LClaw,-127);
	startMotor(RClaw,-127);
	wait(0.5);
	stopMotor(LClaw);
	stopMotor(RClaw);
}

void LiftAll()// Activate the lift to full power... if you couldn't tell.
{
		startMotor(LBLift,FULL);
		startMotor(LTLift,FULL);
		startMotor(RTLift,FULL);
		startMotor(RBLift,FULL);

}

void stopLift()// Stops the lift from lifting in any way... again if you couldn't already tell.
{
    stopMotor(LBLift);
		stopMotor(LTLift);
		stopMotor(RTLift);
		stopMotor(RBLift);

}
void dropLiftFullSpeed()// Will drop the lift at full negative speed down.
{
		startMotor(LBLift,-FULL);
		startMotor(LTLift,-FULL);
		startMotor(RTLift,-FULL);
		startMotor(RBLift,-FULL);
}

/*
//////////////////////
//------------------//
// IMEs Tick values //
//------------------//
//////////////////////

DO NOT TOUCH THIS UNDER ANY CIRCUMSTANCE ONLY ME(EFRAIN).
I have spent hours correctly calculating the turn ticks

500 ticks for one tile.
150 ticks for turning right on the Right Rear drive motor.
130 ticks for turning left on the Left Rear drive motor.

*/


void Driveforward() // The IMEs will take control and drive at the speed of 100 for 500 (ONE TILE) ticks
{
wait1Msec(1);

  resetMotorEncoder(LBDrive);
  resetMotorEncoder(RBDrive);

  while(getMotorEncoder(RBDrive) < 500)
  {
    motor[LBDrive] = 100;
    motor[RBDrive] = 100;
  }
  	motor[LBDrive] = 0;
    motor[RBDrive] = 0;
}
void Drivebackward()
{
wait1Msec(1);

  resetMotorEncoder(LBDrive);
  resetMotorEncoder(RBDrive);

  while(getMotorEncoder(RBDrive) < -500)
  {
    motor[LBDrive] = 100;
    motor[RBDrive] = 100;
  }
  	motor[LBDrive] = 0;
    motor[RBDrive] = 0;
}
void TurnLeft ()
{
  wait1Msec(1);

  //Turn Left 130
  resetMotorEncoder(LBDrive);
  resetMotorEncoder(RBDrive);

  while(getMotorEncoder(RBDrive) < 130)
  {
    motor[LBDrive] = -100;
    motor[RBDrive] = 100;
  }
  	motor[LBDrive] = 0;
    motor[RBDrive] = 0;
}
void TurnRight ()
{
	//Turn Right 150
  wait1Msec(1);

  resetMotorEncoder(LBDrive);
  resetMotorEncoder(RBDrive);

  while(getMotorEncoder(LBDrive) < 150)
  {
    motor[LBDrive] = 100;
    motor[RBDrive] = -100;
  }
  	motor[LBDrive] = 0;
    motor[RBDrive] = 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  Driveforward();
  wait(1);
  TurnLeft();
  wait(1);
  Driveforward();
  wait(1);
  ClawClose();
  wait(1);
  LiftAll();
  wait(1.5);
  TurnRight();
  wait(1);
  Driveforward();
  wait(1);
  ClawOpen();
  wait(1);
  Drivebackward();
  wait(1);
  dropLiftFullSpeed();
  wait(1);
  stopLift();
  wait(1);
  TurnLeft();
  wait(1);
  TurnLeft();
  wait(1);
  Driveforward();
  wait(1);
  Driveforward();
  wait(1);
  ClawClose();
  wait(1);
  TurnRight();
  wait(1);
  TurnRight();
  wait(1);
  LiftAll();
  wait(1);
  Driveforward();
  wait(1);
  Driveforward();
  wait(1);
  ClawOpen();



}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{

  while (true)
  {
    motor(LBDrive) = vexRT[Ch3];
    motor(LFDrive) = vexRT[Ch3];
    motor(RBDrive) = vexRT[Ch2];
    motor(RFDrive) = vexRT[Ch2];
    if(vexRT(Btn5D) == 1)
    {
    	motor[LClaw] = 127;
    	motor[RClaw] = 127;
    }
    else if(vexRT(Btn5U) == 1)
    {
    	motor[LClaw] = -127;
    	motor[RClaw] = -127;
    }
    else
    {
    	motor[LClaw] = 5;
    	motor[RClaw] = 5;
    }

    if(vexRT(Btn6U) == 1)
    {
    	motor[LTLift] = 127;
    	motor[RTLift] = 127;
    	motor[LBLift] = 127;
    	motor[RBLift] = 127;
    }
    else if(vexRT(Btn6D) == 1)
    {
    	motor[LTLift] = -127;
    	motor[RTLift] = -127;
    	motor[LBLift] = -127;
    	motor[RBLift] = -127;
    }
    else
    {
    	motor[LTLift] = 0;
    	motor[RTLift] = 0;
    	motor[LBLift] = 0;
    	motor[RBLift] = 0;
    }
  }
}
